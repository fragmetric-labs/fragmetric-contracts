/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/web3.js';
import {
  getFeeCentsDecoder,
  getFeeCentsEncoder,
  getFeeDecoder,
  getFeeEncoder,
  getLiqPoolDecoder,
  getLiqPoolEncoder,
  getStakeSystemDecoder,
  getStakeSystemEncoder,
  getValidatorSystemDecoder,
  getValidatorSystemEncoder,
  type Fee,
  type FeeArgs,
  type FeeCents,
  type FeeCentsArgs,
  type LiqPool,
  type LiqPoolArgs,
  type StakeSystem,
  type StakeSystemArgs,
  type ValidatorSystem,
  type ValidatorSystemArgs,
} from '../types';

export const STATE_DISCRIMINATOR = new Uint8Array([
  216, 146, 107, 94, 104, 75, 182, 177,
]);

export function getStateDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(STATE_DISCRIMINATOR);
}

export type State = {
  discriminator: ReadonlyUint8Array;
  msolMint: Address;
  adminAuthority: Address;
  operationalSolAccount: Address;
  treasuryMsolAccount: Address;
  reserveBumpSeed: number;
  msolMintAuthorityBumpSeed: number;
  rentExemptForTokenAcc: bigint;
  rewardFee: Fee;
  stakeSystem: StakeSystem;
  validatorSystem: ValidatorSystem;
  liqPool: LiqPool;
  availableReserveBalance: bigint;
  msolSupply: bigint;
  msolPrice: bigint;
  /** count tickets for delayed-unstake */
  circulatingTicketCount: bigint;
  /** total lamports amount of generated and not claimed yet tickets */
  circulatingTicketBalance: bigint;
  lentFromReserve: bigint;
  minDeposit: bigint;
  minWithdraw: bigint;
  stakingSolCap: bigint;
  emergencyCoolingDown: bigint;
  /** emergency pause */
  pauseAuthority: Address;
  paused: boolean;
  delayedUnstakeFee: FeeCents;
  withdrawStakeAccountFee: FeeCents;
  withdrawStakeAccountEnabled: boolean;
  lastStakeMoveEpoch: bigint;
  stakeMoved: bigint;
  maxStakeMovedPerEpoch: Fee;
};

export type StateArgs = {
  msolMint: Address;
  adminAuthority: Address;
  operationalSolAccount: Address;
  treasuryMsolAccount: Address;
  reserveBumpSeed: number;
  msolMintAuthorityBumpSeed: number;
  rentExemptForTokenAcc: number | bigint;
  rewardFee: FeeArgs;
  stakeSystem: StakeSystemArgs;
  validatorSystem: ValidatorSystemArgs;
  liqPool: LiqPoolArgs;
  availableReserveBalance: number | bigint;
  msolSupply: number | bigint;
  msolPrice: number | bigint;
  /** count tickets for delayed-unstake */
  circulatingTicketCount: number | bigint;
  /** total lamports amount of generated and not claimed yet tickets */
  circulatingTicketBalance: number | bigint;
  lentFromReserve: number | bigint;
  minDeposit: number | bigint;
  minWithdraw: number | bigint;
  stakingSolCap: number | bigint;
  emergencyCoolingDown: number | bigint;
  /** emergency pause */
  pauseAuthority: Address;
  paused: boolean;
  delayedUnstakeFee: FeeCentsArgs;
  withdrawStakeAccountFee: FeeCentsArgs;
  withdrawStakeAccountEnabled: boolean;
  lastStakeMoveEpoch: number | bigint;
  stakeMoved: number | bigint;
  maxStakeMovedPerEpoch: FeeArgs;
};

export function getStateEncoder(): Encoder<StateArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['msolMint', getAddressEncoder()],
      ['adminAuthority', getAddressEncoder()],
      ['operationalSolAccount', getAddressEncoder()],
      ['treasuryMsolAccount', getAddressEncoder()],
      ['reserveBumpSeed', getU8Encoder()],
      ['msolMintAuthorityBumpSeed', getU8Encoder()],
      ['rentExemptForTokenAcc', getU64Encoder()],
      ['rewardFee', getFeeEncoder()],
      ['stakeSystem', getStakeSystemEncoder()],
      ['validatorSystem', getValidatorSystemEncoder()],
      ['liqPool', getLiqPoolEncoder()],
      ['availableReserveBalance', getU64Encoder()],
      ['msolSupply', getU64Encoder()],
      ['msolPrice', getU64Encoder()],
      ['circulatingTicketCount', getU64Encoder()],
      ['circulatingTicketBalance', getU64Encoder()],
      ['lentFromReserve', getU64Encoder()],
      ['minDeposit', getU64Encoder()],
      ['minWithdraw', getU64Encoder()],
      ['stakingSolCap', getU64Encoder()],
      ['emergencyCoolingDown', getU64Encoder()],
      ['pauseAuthority', getAddressEncoder()],
      ['paused', getBooleanEncoder()],
      ['delayedUnstakeFee', getFeeCentsEncoder()],
      ['withdrawStakeAccountFee', getFeeCentsEncoder()],
      ['withdrawStakeAccountEnabled', getBooleanEncoder()],
      ['lastStakeMoveEpoch', getU64Encoder()],
      ['stakeMoved', getU64Encoder()],
      ['maxStakeMovedPerEpoch', getFeeEncoder()],
    ]),
    (value) => ({ ...value, discriminator: STATE_DISCRIMINATOR })
  );
}

export function getStateDecoder(): Decoder<State> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['msolMint', getAddressDecoder()],
    ['adminAuthority', getAddressDecoder()],
    ['operationalSolAccount', getAddressDecoder()],
    ['treasuryMsolAccount', getAddressDecoder()],
    ['reserveBumpSeed', getU8Decoder()],
    ['msolMintAuthorityBumpSeed', getU8Decoder()],
    ['rentExemptForTokenAcc', getU64Decoder()],
    ['rewardFee', getFeeDecoder()],
    ['stakeSystem', getStakeSystemDecoder()],
    ['validatorSystem', getValidatorSystemDecoder()],
    ['liqPool', getLiqPoolDecoder()],
    ['availableReserveBalance', getU64Decoder()],
    ['msolSupply', getU64Decoder()],
    ['msolPrice', getU64Decoder()],
    ['circulatingTicketCount', getU64Decoder()],
    ['circulatingTicketBalance', getU64Decoder()],
    ['lentFromReserve', getU64Decoder()],
    ['minDeposit', getU64Decoder()],
    ['minWithdraw', getU64Decoder()],
    ['stakingSolCap', getU64Decoder()],
    ['emergencyCoolingDown', getU64Decoder()],
    ['pauseAuthority', getAddressDecoder()],
    ['paused', getBooleanDecoder()],
    ['delayedUnstakeFee', getFeeCentsDecoder()],
    ['withdrawStakeAccountFee', getFeeCentsDecoder()],
    ['withdrawStakeAccountEnabled', getBooleanDecoder()],
    ['lastStakeMoveEpoch', getU64Decoder()],
    ['stakeMoved', getU64Decoder()],
    ['maxStakeMovedPerEpoch', getFeeDecoder()],
  ]);
}

export function getStateCodec(): Codec<StateArgs, State> {
  return combineCodec(getStateEncoder(), getStateDecoder());
}

export function decodeState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<State, TAddress>;
export function decodeState<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<State, TAddress>;
export function decodeState<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<State, TAddress> | MaybeAccount<State, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getStateDecoder()
  );
}

export async function fetchState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<State, TAddress>> {
  const maybeAccount = await fetchMaybeState(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeState<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<State, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeState(maybeAccount);
}

export async function fetchAllState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<State>[]> {
  const maybeAccounts = await fetchAllMaybeState(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeState(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<State>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeState(maybeAccount));
}

export function getStateSize(): number {
  return 638;
}
