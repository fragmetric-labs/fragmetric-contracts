/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type ReadonlyUint8Array,
} from '@solana/web3.js';
import {
  getRestakingVaultDelegationDecoder,
  getRestakingVaultDelegationEncoder,
  getTokenPricingSourcePodDecoder,
  getTokenPricingSourcePodEncoder,
  type RestakingVaultDelegation,
  type RestakingVaultDelegationArgs,
  type TokenPricingSourcePod,
  type TokenPricingSourcePodArgs,
} from '.';

export type RestakingVault = {
  vault: Address;
  program: Address;
  supportedTokenMint: Address;
  receiptTokenMint: Address;
  receiptTokenProgram: Address;
  receiptTokenDecimals: number;
  padding: ReadonlyUint8Array;
  /** transient price */
  oneReceiptTokenAsSol: bigint;
  receiptTokenPricingSource: TokenPricingSourcePod;
  receiptTokenOperationReservedAmount: bigint;
  /** the amount of vrt being unrestaked */
  receiptTokenOperationReceivableAmount: bigint;
  /** configuration: used for restaking allocation strategy. */
  solAllocationWeight: bigint;
  solAllocationCapacityAmount: bigint;
  padding2: ReadonlyUint8Array;
  numDelegations: number;
  delegations: Array<RestakingVaultDelegation>;
  /** auto-compounding */
  padding3: ReadonlyUint8Array;
  numCompoundingRewardTokens: number;
  compoundingRewardTokenMints: Array<Address>;
  reserved: ReadonlyUint8Array;
};

export type RestakingVaultArgs = {
  vault: Address;
  program: Address;
  supportedTokenMint: Address;
  receiptTokenMint: Address;
  receiptTokenProgram: Address;
  receiptTokenDecimals: number;
  padding: ReadonlyUint8Array;
  /** transient price */
  oneReceiptTokenAsSol: number | bigint;
  receiptTokenPricingSource: TokenPricingSourcePodArgs;
  receiptTokenOperationReservedAmount: number | bigint;
  /** the amount of vrt being unrestaked */
  receiptTokenOperationReceivableAmount: number | bigint;
  /** configuration: used for restaking allocation strategy. */
  solAllocationWeight: number | bigint;
  solAllocationCapacityAmount: number | bigint;
  padding2: ReadonlyUint8Array;
  numDelegations: number;
  delegations: Array<RestakingVaultDelegationArgs>;
  /** auto-compounding */
  padding3: ReadonlyUint8Array;
  numCompoundingRewardTokens: number;
  compoundingRewardTokenMints: Array<Address>;
  reserved: ReadonlyUint8Array;
};

export function getRestakingVaultEncoder(): Encoder<RestakingVaultArgs> {
  return getStructEncoder([
    ['vault', getAddressEncoder()],
    ['program', getAddressEncoder()],
    ['supportedTokenMint', getAddressEncoder()],
    ['receiptTokenMint', getAddressEncoder()],
    ['receiptTokenProgram', getAddressEncoder()],
    ['receiptTokenDecimals', getU8Encoder()],
    ['padding', fixEncoderSize(getBytesEncoder(), 7)],
    ['oneReceiptTokenAsSol', getU64Encoder()],
    ['receiptTokenPricingSource', getTokenPricingSourcePodEncoder()],
    ['receiptTokenOperationReservedAmount', getU64Encoder()],
    ['receiptTokenOperationReceivableAmount', getU64Encoder()],
    ['solAllocationWeight', getU64Encoder()],
    ['solAllocationCapacityAmount', getU64Encoder()],
    ['padding2', fixEncoderSize(getBytesEncoder(), 7)],
    ['numDelegations', getU8Encoder()],
    [
      'delegations',
      getArrayEncoder(getRestakingVaultDelegationEncoder(), { size: 30 }),
    ],
    ['padding3', fixEncoderSize(getBytesEncoder(), 7)],
    ['numCompoundingRewardTokens', getU8Encoder()],
    [
      'compoundingRewardTokenMints',
      getArrayEncoder(getAddressEncoder(), { size: 10 }),
    ],
    ['reserved', fixEncoderSize(getBytesEncoder(), 128)],
  ]);
}

export function getRestakingVaultDecoder(): Decoder<RestakingVault> {
  return getStructDecoder([
    ['vault', getAddressDecoder()],
    ['program', getAddressDecoder()],
    ['supportedTokenMint', getAddressDecoder()],
    ['receiptTokenMint', getAddressDecoder()],
    ['receiptTokenProgram', getAddressDecoder()],
    ['receiptTokenDecimals', getU8Decoder()],
    ['padding', fixDecoderSize(getBytesDecoder(), 7)],
    ['oneReceiptTokenAsSol', getU64Decoder()],
    ['receiptTokenPricingSource', getTokenPricingSourcePodDecoder()],
    ['receiptTokenOperationReservedAmount', getU64Decoder()],
    ['receiptTokenOperationReceivableAmount', getU64Decoder()],
    ['solAllocationWeight', getU64Decoder()],
    ['solAllocationCapacityAmount', getU64Decoder()],
    ['padding2', fixDecoderSize(getBytesDecoder(), 7)],
    ['numDelegations', getU8Decoder()],
    [
      'delegations',
      getArrayDecoder(getRestakingVaultDelegationDecoder(), { size: 30 }),
    ],
    ['padding3', fixDecoderSize(getBytesDecoder(), 7)],
    ['numCompoundingRewardTokens', getU8Decoder()],
    [
      'compoundingRewardTokenMints',
      getArrayDecoder(getAddressDecoder(), { size: 10 }),
    ],
    ['reserved', fixDecoderSize(getBytesDecoder(), 128)],
  ]);
}

export function getRestakingVaultCodec(): Codec<
  RestakingVaultArgs,
  RestakingVault
> {
  return combineCodec(getRestakingVaultEncoder(), getRestakingVaultDecoder());
}
