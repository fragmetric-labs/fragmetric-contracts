/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type Codec,
  type Decoder,
  type EncodedAccount,
  type Encoder,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getAssetStateDecoder,
  getAssetStateEncoder,
  getNormalizedTokenDecoder,
  getNormalizedTokenEncoder,
  getOperationStateDecoder,
  getOperationStateEncoder,
  getRestakingVaultDecoder,
  getRestakingVaultEncoder,
  getSupportedTokenDecoder,
  getSupportedTokenEncoder,
  getTokenSwapStrategyDecoder,
  getTokenSwapStrategyEncoder,
  getTokenValuePodDecoder,
  getTokenValuePodEncoder,
  getWrappedTokenDecoder,
  getWrappedTokenEncoder,
  type AssetState,
  type AssetStateArgs,
  type NormalizedToken,
  type NormalizedTokenArgs,
  type OperationState,
  type OperationStateArgs,
  type RestakingVault,
  type RestakingVaultArgs,
  type SupportedToken,
  type SupportedTokenArgs,
  type TokenSwapStrategy,
  type TokenSwapStrategyArgs,
  type TokenValuePod,
  type TokenValuePodArgs,
  type WrappedToken,
  type WrappedTokenArgs,
} from '../types';

export const FUND_ACCOUNT_DISCRIMINATOR = new Uint8Array([
  49, 104, 168, 214, 134, 180, 173, 154,
]);

export function getFundAccountDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    FUND_ACCOUNT_DISCRIMINATOR
  );
}

export type FundAccount = {
  discriminator: ReadonlyUint8Array;
  dataVersion: number;
  bump: number;
  reserveAccountBump: number;
  treasuryAccountBump: number;
  wrapAccountBump: number;
  padding: ReadonlyUint8Array;
  transferEnabled: number;
  addressLookupTableEnabled: number;
  addressLookupTableAccount: Address;
  reserveAccount: Address;
  treasuryAccount: Address;
  /** receipt token information */
  receiptTokenMint: Address;
  receiptTokenProgram: Address;
  receiptTokenDecimals: number;
  padding2: ReadonlyUint8Array;
  receiptTokenSupplyAmount: bigint;
  oneReceiptTokenAsSol: bigint;
  receiptTokenValueUpdatedSlot: bigint;
  receiptTokenValue: TokenValuePod;
  /** global withdrawal configurations */
  withdrawalBatchThresholdIntervalSeconds: bigint;
  withdrawalFeeRateBps: number;
  withdrawalEnabled: number;
  depositEnabled: number;
  donationEnabled: number;
  padding3: ReadonlyUint8Array;
  /** SOL deposit & withdrawal */
  sol: AssetState;
  /** underlying assets */
  padding4: ReadonlyUint8Array;
  numSupportedTokens: number;
  supportedTokens: Array<SupportedToken>;
  reserved2: ReadonlyUint8Array;
  /** optional basket of underlying assets */
  normalizedToken: NormalizedToken;
  /** investments */
  padding5: ReadonlyUint8Array;
  numRestakingVaults: number;
  restakingVaults: Array<RestakingVault>;
  reserved: ReadonlyUint8Array;
  /** fund operation state */
  operation: OperationState;
  /** optional wrapped token of fund receipt token */
  wrapAccount: Address;
  wrappedToken: WrappedToken;
  /** which DEX to use for swap between two tokens */
  numTokenSwapStrategies: number;
  padding6: ReadonlyUint8Array;
  tokenSwapStrategies: Array<TokenSwapStrategy>;
  reserved1: ReadonlyUint8Array;
};

export type FundAccountArgs = {
  dataVersion: number;
  bump: number;
  reserveAccountBump: number;
  treasuryAccountBump: number;
  wrapAccountBump: number;
  padding: ReadonlyUint8Array;
  transferEnabled: number;
  addressLookupTableEnabled: number;
  addressLookupTableAccount: Address;
  reserveAccount: Address;
  treasuryAccount: Address;
  /** receipt token information */
  receiptTokenMint: Address;
  receiptTokenProgram: Address;
  receiptTokenDecimals: number;
  padding2: ReadonlyUint8Array;
  receiptTokenSupplyAmount: number | bigint;
  oneReceiptTokenAsSol: number | bigint;
  receiptTokenValueUpdatedSlot: number | bigint;
  receiptTokenValue: TokenValuePodArgs;
  /** global withdrawal configurations */
  withdrawalBatchThresholdIntervalSeconds: number | bigint;
  withdrawalFeeRateBps: number;
  withdrawalEnabled: number;
  depositEnabled: number;
  donationEnabled: number;
  padding3: ReadonlyUint8Array;
  /** SOL deposit & withdrawal */
  sol: AssetStateArgs;
  /** underlying assets */
  padding4: ReadonlyUint8Array;
  numSupportedTokens: number;
  supportedTokens: Array<SupportedTokenArgs>;
  reserved2: ReadonlyUint8Array;
  /** optional basket of underlying assets */
  normalizedToken: NormalizedTokenArgs;
  /** investments */
  padding5: ReadonlyUint8Array;
  numRestakingVaults: number;
  restakingVaults: Array<RestakingVaultArgs>;
  reserved: ReadonlyUint8Array;
  /** fund operation state */
  operation: OperationStateArgs;
  /** optional wrapped token of fund receipt token */
  wrapAccount: Address;
  wrappedToken: WrappedTokenArgs;
  /** which DEX to use for swap between two tokens */
  numTokenSwapStrategies: number;
  padding6: ReadonlyUint8Array;
  tokenSwapStrategies: Array<TokenSwapStrategyArgs>;
  reserved1: ReadonlyUint8Array;
};

export function getFundAccountEncoder(): Encoder<FundAccountArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['dataVersion', getU16Encoder()],
      ['bump', getU8Encoder()],
      ['reserveAccountBump', getU8Encoder()],
      ['treasuryAccountBump', getU8Encoder()],
      ['wrapAccountBump', getU8Encoder()],
      ['padding', fixEncoderSize(getBytesEncoder(), 8)],
      ['transferEnabled', getU8Encoder()],
      ['addressLookupTableEnabled', getU8Encoder()],
      ['addressLookupTableAccount', getAddressEncoder()],
      ['reserveAccount', getAddressEncoder()],
      ['treasuryAccount', getAddressEncoder()],
      ['receiptTokenMint', getAddressEncoder()],
      ['receiptTokenProgram', getAddressEncoder()],
      ['receiptTokenDecimals', getU8Encoder()],
      ['padding2', fixEncoderSize(getBytesEncoder(), 7)],
      ['receiptTokenSupplyAmount', getU64Encoder()],
      ['oneReceiptTokenAsSol', getU64Encoder()],
      ['receiptTokenValueUpdatedSlot', getU64Encoder()],
      ['receiptTokenValue', getTokenValuePodEncoder()],
      ['withdrawalBatchThresholdIntervalSeconds', getI64Encoder()],
      ['withdrawalFeeRateBps', getU16Encoder()],
      ['withdrawalEnabled', getU8Encoder()],
      ['depositEnabled', getU8Encoder()],
      ['donationEnabled', getU8Encoder()],
      ['padding3', fixEncoderSize(getBytesEncoder(), 3)],
      ['sol', getAssetStateEncoder()],
      ['padding4', fixEncoderSize(getBytesEncoder(), 15)],
      ['numSupportedTokens', getU8Encoder()],
      [
        'supportedTokens',
        getArrayEncoder(getSupportedTokenEncoder(), { size: 16 }),
      ],
      ['reserved2', fixEncoderSize(getBytesEncoder(), 16016)],
      ['normalizedToken', getNormalizedTokenEncoder()],
      ['padding5', fixEncoderSize(getBytesEncoder(), 15)],
      ['numRestakingVaults', getU8Encoder()],
      [
        'restakingVaults',
        getArrayEncoder(getRestakingVaultEncoder(), { size: 16 }),
      ],
      ['reserved', fixEncoderSize(getBytesEncoder(), 112)],
      ['operation', getOperationStateEncoder()],
      ['wrapAccount', getAddressEncoder()],
      ['wrappedToken', getWrappedTokenEncoder()],
      ['numTokenSwapStrategies', getU8Encoder()],
      ['padding6', fixEncoderSize(getBytesEncoder(), 7)],
      [
        'tokenSwapStrategies',
        getArrayEncoder(getTokenSwapStrategyEncoder(), { size: 30 }),
      ],
      ['reserved1', fixEncoderSize(getBytesEncoder(), 3616)],
    ]),
    (value) => ({ ...value, discriminator: FUND_ACCOUNT_DISCRIMINATOR })
  );
}

export function getFundAccountDecoder(): Decoder<FundAccount> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['dataVersion', getU16Decoder()],
    ['bump', getU8Decoder()],
    ['reserveAccountBump', getU8Decoder()],
    ['treasuryAccountBump', getU8Decoder()],
    ['wrapAccountBump', getU8Decoder()],
    ['padding', fixDecoderSize(getBytesDecoder(), 8)],
    ['transferEnabled', getU8Decoder()],
    ['addressLookupTableEnabled', getU8Decoder()],
    ['addressLookupTableAccount', getAddressDecoder()],
    ['reserveAccount', getAddressDecoder()],
    ['treasuryAccount', getAddressDecoder()],
    ['receiptTokenMint', getAddressDecoder()],
    ['receiptTokenProgram', getAddressDecoder()],
    ['receiptTokenDecimals', getU8Decoder()],
    ['padding2', fixDecoderSize(getBytesDecoder(), 7)],
    ['receiptTokenSupplyAmount', getU64Decoder()],
    ['oneReceiptTokenAsSol', getU64Decoder()],
    ['receiptTokenValueUpdatedSlot', getU64Decoder()],
    ['receiptTokenValue', getTokenValuePodDecoder()],
    ['withdrawalBatchThresholdIntervalSeconds', getI64Decoder()],
    ['withdrawalFeeRateBps', getU16Decoder()],
    ['withdrawalEnabled', getU8Decoder()],
    ['depositEnabled', getU8Decoder()],
    ['donationEnabled', getU8Decoder()],
    ['padding3', fixDecoderSize(getBytesDecoder(), 3)],
    ['sol', getAssetStateDecoder()],
    ['padding4', fixDecoderSize(getBytesDecoder(), 15)],
    ['numSupportedTokens', getU8Decoder()],
    [
      'supportedTokens',
      getArrayDecoder(getSupportedTokenDecoder(), { size: 16 }),
    ],
    ['reserved2', fixDecoderSize(getBytesDecoder(), 16016)],
    ['normalizedToken', getNormalizedTokenDecoder()],
    ['padding5', fixDecoderSize(getBytesDecoder(), 15)],
    ['numRestakingVaults', getU8Decoder()],
    [
      'restakingVaults',
      getArrayDecoder(getRestakingVaultDecoder(), { size: 16 }),
    ],
    ['reserved', fixDecoderSize(getBytesDecoder(), 112)],
    ['operation', getOperationStateDecoder()],
    ['wrapAccount', getAddressDecoder()],
    ['wrappedToken', getWrappedTokenDecoder()],
    ['numTokenSwapStrategies', getU8Decoder()],
    ['padding6', fixDecoderSize(getBytesDecoder(), 7)],
    [
      'tokenSwapStrategies',
      getArrayDecoder(getTokenSwapStrategyDecoder(), { size: 30 }),
    ],
    ['reserved1', fixDecoderSize(getBytesDecoder(), 3616)],
  ]);
}

export function getFundAccountCodec(): Codec<FundAccountArgs, FundAccount> {
  return combineCodec(getFundAccountEncoder(), getFundAccountDecoder());
}

export function decodeFundAccount<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<FundAccount, TAddress>;
export function decodeFundAccount<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<FundAccount, TAddress>;
export function decodeFundAccount<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<FundAccount, TAddress> | MaybeAccount<FundAccount, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getFundAccountDecoder()
  );
}

export async function fetchFundAccount<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<FundAccount, TAddress>> {
  const maybeAccount = await fetchMaybeFundAccount(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeFundAccount<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<FundAccount, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeFundAccount(maybeAccount);
}

export async function fetchAllFundAccount(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<FundAccount>[]> {
  const maybeAccounts = await fetchAllMaybeFundAccount(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeFundAccount(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<FundAccount>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeFundAccount(maybeAccount));
}

export function getFundAccountSize(): number {
  return 163840;
}
