/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI128Decoder,
  getI128Encoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getRestakingVaultDelegationDecoder,
  getRestakingVaultDelegationEncoder,
  getRewardTokenDecoder,
  getRewardTokenEncoder,
  getTokenExchangeRatioDecoder,
  getTokenExchangeRatioEncoder,
  getTokenPricingSourcePodDecoder,
  getTokenPricingSourcePodEncoder,
  type RestakingVaultDelegation,
  type RestakingVaultDelegationArgs,
  type RewardToken,
  type RewardTokenArgs,
  type TokenExchangeRatio,
  type TokenExchangeRatioArgs,
  type TokenPricingSourcePod,
  type TokenPricingSourcePodArgs,
} from '.';

export type RestakingVault = {
  vault: Address;
  program: Address;
  supportedTokenMint: Address;
  receiptTokenMint: Address;
  receiptTokenProgram: Address;
  receiptTokenDecimals: number;
  padding: ReadonlyUint8Array;
  /** transient price */
  oneReceiptTokenAsSol: bigint;
  receiptTokenPricingSource: TokenPricingSourcePod;
  receiptTokenOperationReservedAmount: bigint;
  /** the amount of vrt being unrestaked */
  receiptTokenOperationReceivableAmount: bigint;
  /** configuration: used for restaking allocation strategy. */
  solAllocationWeight: bigint;
  solAllocationCapacityAmount: bigint;
  padding2: ReadonlyUint8Array;
  numDelegations: number;
  delegations: Array<RestakingVaultDelegation>;
  rewardCommissionRateBps: number;
  /** auto-compounding */
  padding3: ReadonlyUint8Array;
  numCompoundingRewardTokens: number;
  compoundingRewardTokens: Array<RewardToken>;
  /** reward to distribute */
  padding4: ReadonlyUint8Array;
  numDistributingRewardTokens: number;
  distributingRewardTokens: Array<RewardToken>;
  supportedTokenCompoundedAmount: bigint;
  supportedTokenToReceiptTokenExchangeRatio: TokenExchangeRatio;
  supportedTokenToReceiptTokenExchangeRatioUpdatedTimestamp: bigint;
  padding5: ReadonlyUint8Array;
  /**
   * Expected amount of vst by unrestaking vrt.
   * This field is updated when the vault uses vst as expected receivable amount after unrestaking process is completed.
   * It does NOT include unrestaking amount as vrt.
   */
  pendingSupportedTokenUnrestakingAmount: bigint;
  receiptTokenDepositable: number;
  reserved: ReadonlyUint8Array;
};

export type RestakingVaultArgs = {
  vault: Address;
  program: Address;
  supportedTokenMint: Address;
  receiptTokenMint: Address;
  receiptTokenProgram: Address;
  receiptTokenDecimals: number;
  padding: ReadonlyUint8Array;
  /** transient price */
  oneReceiptTokenAsSol: number | bigint;
  receiptTokenPricingSource: TokenPricingSourcePodArgs;
  receiptTokenOperationReservedAmount: number | bigint;
  /** the amount of vrt being unrestaked */
  receiptTokenOperationReceivableAmount: number | bigint;
  /** configuration: used for restaking allocation strategy. */
  solAllocationWeight: number | bigint;
  solAllocationCapacityAmount: number | bigint;
  padding2: ReadonlyUint8Array;
  numDelegations: number;
  delegations: Array<RestakingVaultDelegationArgs>;
  rewardCommissionRateBps: number;
  /** auto-compounding */
  padding3: ReadonlyUint8Array;
  numCompoundingRewardTokens: number;
  compoundingRewardTokens: Array<RewardTokenArgs>;
  /** reward to distribute */
  padding4: ReadonlyUint8Array;
  numDistributingRewardTokens: number;
  distributingRewardTokens: Array<RewardTokenArgs>;
  supportedTokenCompoundedAmount: number | bigint;
  supportedTokenToReceiptTokenExchangeRatio: TokenExchangeRatioArgs;
  supportedTokenToReceiptTokenExchangeRatioUpdatedTimestamp: number | bigint;
  padding5: ReadonlyUint8Array;
  /**
   * Expected amount of vst by unrestaking vrt.
   * This field is updated when the vault uses vst as expected receivable amount after unrestaking process is completed.
   * It does NOT include unrestaking amount as vrt.
   */
  pendingSupportedTokenUnrestakingAmount: number | bigint;
  receiptTokenDepositable: number;
  reserved: ReadonlyUint8Array;
};

export function getRestakingVaultEncoder(): Encoder<RestakingVaultArgs> {
  return getStructEncoder([
    ['vault', getAddressEncoder()],
    ['program', getAddressEncoder()],
    ['supportedTokenMint', getAddressEncoder()],
    ['receiptTokenMint', getAddressEncoder()],
    ['receiptTokenProgram', getAddressEncoder()],
    ['receiptTokenDecimals', getU8Encoder()],
    ['padding', fixEncoderSize(getBytesEncoder(), 7)],
    ['oneReceiptTokenAsSol', getU64Encoder()],
    ['receiptTokenPricingSource', getTokenPricingSourcePodEncoder()],
    ['receiptTokenOperationReservedAmount', getU64Encoder()],
    ['receiptTokenOperationReceivableAmount', getU64Encoder()],
    ['solAllocationWeight', getU64Encoder()],
    ['solAllocationCapacityAmount', getU64Encoder()],
    ['padding2', fixEncoderSize(getBytesEncoder(), 7)],
    ['numDelegations', getU8Encoder()],
    [
      'delegations',
      getArrayEncoder(getRestakingVaultDelegationEncoder(), { size: 30 }),
    ],
    ['rewardCommissionRateBps', getU16Encoder()],
    ['padding3', fixEncoderSize(getBytesEncoder(), 5)],
    ['numCompoundingRewardTokens', getU8Encoder()],
    [
      'compoundingRewardTokens',
      getArrayEncoder(getRewardTokenEncoder(), { size: 4 }),
    ],
    ['padding4', fixEncoderSize(getBytesEncoder(), 7)],
    ['numDistributingRewardTokens', getU8Encoder()],
    [
      'distributingRewardTokens',
      getArrayEncoder(getRewardTokenEncoder(), { size: 30 }),
    ],
    ['supportedTokenCompoundedAmount', getI128Encoder()],
    [
      'supportedTokenToReceiptTokenExchangeRatio',
      getTokenExchangeRatioEncoder(),
    ],
    [
      'supportedTokenToReceiptTokenExchangeRatioUpdatedTimestamp',
      getI64Encoder(),
    ],
    ['padding5', fixEncoderSize(getBytesEncoder(), 32)],
    ['pendingSupportedTokenUnrestakingAmount', getU64Encoder()],
    ['receiptTokenDepositable', getU8Encoder()],
    ['reserved', fixEncoderSize(getBytesEncoder(), 775)],
  ]);
}

export function getRestakingVaultDecoder(): Decoder<RestakingVault> {
  return getStructDecoder([
    ['vault', getAddressDecoder()],
    ['program', getAddressDecoder()],
    ['supportedTokenMint', getAddressDecoder()],
    ['receiptTokenMint', getAddressDecoder()],
    ['receiptTokenProgram', getAddressDecoder()],
    ['receiptTokenDecimals', getU8Decoder()],
    ['padding', fixDecoderSize(getBytesDecoder(), 7)],
    ['oneReceiptTokenAsSol', getU64Decoder()],
    ['receiptTokenPricingSource', getTokenPricingSourcePodDecoder()],
    ['receiptTokenOperationReservedAmount', getU64Decoder()],
    ['receiptTokenOperationReceivableAmount', getU64Decoder()],
    ['solAllocationWeight', getU64Decoder()],
    ['solAllocationCapacityAmount', getU64Decoder()],
    ['padding2', fixDecoderSize(getBytesDecoder(), 7)],
    ['numDelegations', getU8Decoder()],
    [
      'delegations',
      getArrayDecoder(getRestakingVaultDelegationDecoder(), { size: 30 }),
    ],
    ['rewardCommissionRateBps', getU16Decoder()],
    ['padding3', fixDecoderSize(getBytesDecoder(), 5)],
    ['numCompoundingRewardTokens', getU8Decoder()],
    [
      'compoundingRewardTokens',
      getArrayDecoder(getRewardTokenDecoder(), { size: 4 }),
    ],
    ['padding4', fixDecoderSize(getBytesDecoder(), 7)],
    ['numDistributingRewardTokens', getU8Decoder()],
    [
      'distributingRewardTokens',
      getArrayDecoder(getRewardTokenDecoder(), { size: 30 }),
    ],
    ['supportedTokenCompoundedAmount', getI128Decoder()],
    [
      'supportedTokenToReceiptTokenExchangeRatio',
      getTokenExchangeRatioDecoder(),
    ],
    [
      'supportedTokenToReceiptTokenExchangeRatioUpdatedTimestamp',
      getI64Decoder(),
    ],
    ['padding5', fixDecoderSize(getBytesDecoder(), 32)],
    ['pendingSupportedTokenUnrestakingAmount', getU64Decoder()],
    ['receiptTokenDepositable', getU8Decoder()],
    ['reserved', fixDecoderSize(getBytesDecoder(), 775)],
  ]);
}

export function getRestakingVaultCodec(): Codec<
  RestakingVaultArgs,
  RestakingVault
> {
  return combineCodec(getRestakingVaultEncoder(), getRestakingVaultDecoder());
}
