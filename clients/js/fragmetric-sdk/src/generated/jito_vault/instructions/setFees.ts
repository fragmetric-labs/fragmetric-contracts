/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  getOptionDecoder,
  getOptionEncoder,
  getStructDecoder,
  getStructEncoder,
  getU16Decoder,
  getU16Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type Option,
  type OptionOrNullable,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit';
import { JITO_VAULT_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const SET_FEES_DISCRIMINATOR = 16;

export function getSetFeesDiscriminatorBytes() {
  return getU8Encoder().encode(SET_FEES_DISCRIMINATOR);
}

export type SetFeesInstruction<
  TProgram extends string = typeof JITO_VAULT_PROGRAM_ADDRESS,
  TAccountConfig extends string | AccountMeta<string> = string,
  TAccountVault extends string | AccountMeta<string> = string,
  TAccountAdmin extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountConfig extends string
        ? ReadonlyAccount<TAccountConfig>
        : TAccountConfig,
      TAccountVault extends string
        ? WritableAccount<TAccountVault>
        : TAccountVault,
      TAccountAdmin extends string
        ? ReadonlySignerAccount<TAccountAdmin> &
            AccountSignerMeta<TAccountAdmin>
        : TAccountAdmin,
      ...TRemainingAccounts,
    ]
  >;

export type SetFeesInstructionData = {
  discriminator: number;
  depositFeeBps: Option<number>;
  withdrawalFeeBps: Option<number>;
  rewardFeeBps: Option<number>;
};

export type SetFeesInstructionDataArgs = {
  depositFeeBps: OptionOrNullable<number>;
  withdrawalFeeBps: OptionOrNullable<number>;
  rewardFeeBps: OptionOrNullable<number>;
};

export function getSetFeesInstructionDataEncoder(): Encoder<SetFeesInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', getU8Encoder()],
      ['depositFeeBps', getOptionEncoder(getU16Encoder())],
      ['withdrawalFeeBps', getOptionEncoder(getU16Encoder())],
      ['rewardFeeBps', getOptionEncoder(getU16Encoder())],
    ]),
    (value) => ({ ...value, discriminator: SET_FEES_DISCRIMINATOR })
  );
}

export function getSetFeesInstructionDataDecoder(): Decoder<SetFeesInstructionData> {
  return getStructDecoder([
    ['discriminator', getU8Decoder()],
    ['depositFeeBps', getOptionDecoder(getU16Decoder())],
    ['withdrawalFeeBps', getOptionDecoder(getU16Decoder())],
    ['rewardFeeBps', getOptionDecoder(getU16Decoder())],
  ]);
}

export function getSetFeesInstructionDataCodec(): Codec<
  SetFeesInstructionDataArgs,
  SetFeesInstructionData
> {
  return combineCodec(
    getSetFeesInstructionDataEncoder(),
    getSetFeesInstructionDataDecoder()
  );
}

export type SetFeesInput<
  TAccountConfig extends string = string,
  TAccountVault extends string = string,
  TAccountAdmin extends string = string,
> = {
  config: Address<TAccountConfig>;
  vault: Address<TAccountVault>;
  admin: TransactionSigner<TAccountAdmin>;
  depositFeeBps: SetFeesInstructionDataArgs['depositFeeBps'];
  withdrawalFeeBps: SetFeesInstructionDataArgs['withdrawalFeeBps'];
  rewardFeeBps: SetFeesInstructionDataArgs['rewardFeeBps'];
};

export function getSetFeesInstruction<
  TAccountConfig extends string,
  TAccountVault extends string,
  TAccountAdmin extends string,
  TProgramAddress extends Address = typeof JITO_VAULT_PROGRAM_ADDRESS,
>(
  input: SetFeesInput<TAccountConfig, TAccountVault, TAccountAdmin>,
  config?: { programAddress?: TProgramAddress }
): SetFeesInstruction<
  TProgramAddress,
  TAccountConfig,
  TAccountVault,
  TAccountAdmin
> {
  // Program address.
  const programAddress = config?.programAddress ?? JITO_VAULT_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    config: { value: input.config ?? null, isWritable: false },
    vault: { value: input.vault ?? null, isWritable: true },
    admin: { value: input.admin ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  return Object.freeze({
    accounts: [
      getAccountMeta(accounts.config),
      getAccountMeta(accounts.vault),
      getAccountMeta(accounts.admin),
    ],
    data: getSetFeesInstructionDataEncoder().encode(
      args as SetFeesInstructionDataArgs
    ),
    programAddress,
  } as SetFeesInstruction<
    TProgramAddress,
    TAccountConfig,
    TAccountVault,
    TAccountAdmin
  >);
}

export type ParsedSetFeesInstruction<
  TProgram extends string = typeof JITO_VAULT_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    config: TAccountMetas[0];
    vault: TAccountMetas[1];
    admin: TAccountMetas[2];
  };
  data: SetFeesInstructionData;
};

export function parseSetFeesInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedSetFeesInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 3) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      config: getNextAccount(),
      vault: getNextAccount(),
      admin: getNextAccount(),
    },
    data: getSetFeesInstructionDataDecoder().decode(instruction.data),
  };
}
