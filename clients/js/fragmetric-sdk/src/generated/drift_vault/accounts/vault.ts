/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  assertAccountExists,
  assertAccountsExist,
  combineCodec,
  decodeAccount,
  fetchEncodedAccount,
  fetchEncodedAccounts,
  fixDecoderSize,
  fixEncoderSize,
  getAddressDecoder,
  getAddressEncoder,
  getArrayDecoder,
  getArrayEncoder,
  getBooleanDecoder,
  getBooleanEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getI64Decoder,
  getI64Encoder,
  getStructDecoder,
  getStructEncoder,
  getU128Decoder,
  getU128Encoder,
  getU16Decoder,
  getU16Encoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  getU8Decoder,
  getU8Encoder,
  transformEncoder,
  type Account,
  type Address,
  type EncodedAccount,
  type FetchAccountConfig,
  type FetchAccountsConfig,
  type FixedSizeCodec,
  type FixedSizeDecoder,
  type FixedSizeEncoder,
  type MaybeAccount,
  type MaybeEncodedAccount,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  getWithdrawRequestDecoder,
  getWithdrawRequestEncoder,
  type WithdrawRequest,
  type WithdrawRequestArgs,
} from '../types';

export const VAULT_DISCRIMINATOR = new Uint8Array([
  211, 8, 232, 43, 2, 152, 117, 119,
]);

export function getVaultDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(VAULT_DISCRIMINATOR);
}

export type Vault = {
  discriminator: ReadonlyUint8Array;
  /** The name of the vault. Vault pubkey is derived from this name. */
  name: ReadonlyUint8Array;
  /** The vault's pubkey. It is a pda of name and also used as the authority for drift user */
  pubkey: Address;
  /** The manager of the vault who has ability to update vault params */
  manager: Address;
  /** The vaults token account. Used to receive tokens between deposits and withdrawals */
  tokenAccount: Address;
  /** The drift user stats account for the vault */
  userStats: Address;
  /** The drift user account for the vault */
  user: Address;
  /**
   * The vaults designated delegate for drift user account
   * can differ from actual user delegate if vault is in liquidation
   */
  delegate: Address;
  /** The delegate handling liquidation for depositor */
  liquidationDelegate: Address;
  /** The sum of all shares held by the users (vault depositors) */
  userShares: bigint;
  /**
   * The sum of all shares: deposits from users, manager deposits, manager profit/fee, and protocol profit/fee.
   * The manager deposits are total_shares - user_shares - protocol_profit_and_fee_shares.
   */
  totalShares: bigint;
  /** Last fee update unix timestamp */
  lastFeeUpdateTs: bigint;
  /** When the liquidation starts */
  liquidationStartTs: bigint;
  /**
   * The period (in seconds) that a vault depositor must wait after requesting a withdrawal to finalize withdrawal.
   * Currently, the maximum is 90 days.
   */
  redeemPeriod: bigint;
  /** The sum of all outstanding withdraw requests */
  totalWithdrawRequested: bigint;
  /** Max token capacity, once hit/passed vault will reject new deposits (updatable) */
  maxTokens: bigint;
  /**
   * The annual fee charged on deposits by the manager.
   * Traditional funds typically charge 2% per year on assets under management.
   */
  managementFee: bigint;
  /** Timestamp vault initialized */
  initTs: bigint;
  /** The net deposits for the vault */
  netDeposits: bigint;
  /** The net deposits for the manager */
  managerNetDeposits: bigint;
  /** Total deposits */
  totalDeposits: bigint;
  /** Total withdraws */
  totalWithdraws: bigint;
  /** Total deposits for the manager */
  managerTotalDeposits: bigint;
  /** Total withdraws for the manager */
  managerTotalWithdraws: bigint;
  /** Total management fee accrued by the manager */
  managerTotalFee: bigint;
  /** Total profit share accrued by the manager */
  managerTotalProfitShare: bigint;
  /** The minimum deposit amount */
  minDepositAmount: bigint;
  lastManagerWithdrawRequest: WithdrawRequest;
  /** The base 10 exponent of the shares (given massive share inflation can occur at near zero vault equity) */
  sharesBase: number;
  /** Percentage the manager charges on all profits realized by depositors: PERCENTAGE_PRECISION */
  profitShare: number;
  /** Vault manager only collect incentive fees during periods when returns are higher than this amount: PERCENTAGE_PRECISION */
  hurdleRate: number;
  /** The spot market index the vault deposits into/withdraws from */
  spotMarketIndex: number;
  /** The bump for the vault pda */
  bump: number;
  /** Whether anybody can be a depositor */
  permissioned: boolean;
  /** The optional [`VaultProtocol`] account. */
  vaultProtocol: boolean;
  /** How fuel distribution should be treated [`FuelDistributionMode`]. Default is `UsersOnly` */
  fuelDistributionMode: number;
  /**
   * Whether the vault has a FeeUpdate account [`FeeUpdateStatus`]. Default is `FeeUpdateStatus::None`
   * After a `FeeUpdate` account is created and the manager has staged a fee update, the status is set to `PendingFeeUpdate`.
   * And instructsions that may finalize the fee update must include the `FeeUpdate` account with `remaining_accounts`.
   */
  feeUpdateStatus: number;
  /** The class of the vault [`VaultClass`]. Default is `VaultClass::Normal` */
  vaultClass: number;
  /** The timestamp cumulative_fuel_per_share was last updated */
  lastCumulativeFuelPerShareTs: number;
  /** The cumulative fuel per share (scaled up by 1e6 to avoid losing precision) */
  cumulativeFuelPerShare: bigint;
  /** The total fuel accumulated */
  cumulativeFuel: bigint;
  /**
   * The total value (in deposit asset) of borrows the manager has outstanding.
   * Purely for informational purposes for assets that have left the vault that the manager
   * is expected to return.
   */
  managerBorrowedValue: bigint;
  padding: Array<bigint>;
};

export type VaultArgs = {
  /** The name of the vault. Vault pubkey is derived from this name. */
  name: ReadonlyUint8Array;
  /** The vault's pubkey. It is a pda of name and also used as the authority for drift user */
  pubkey: Address;
  /** The manager of the vault who has ability to update vault params */
  manager: Address;
  /** The vaults token account. Used to receive tokens between deposits and withdrawals */
  tokenAccount: Address;
  /** The drift user stats account for the vault */
  userStats: Address;
  /** The drift user account for the vault */
  user: Address;
  /**
   * The vaults designated delegate for drift user account
   * can differ from actual user delegate if vault is in liquidation
   */
  delegate: Address;
  /** The delegate handling liquidation for depositor */
  liquidationDelegate: Address;
  /** The sum of all shares held by the users (vault depositors) */
  userShares: number | bigint;
  /**
   * The sum of all shares: deposits from users, manager deposits, manager profit/fee, and protocol profit/fee.
   * The manager deposits are total_shares - user_shares - protocol_profit_and_fee_shares.
   */
  totalShares: number | bigint;
  /** Last fee update unix timestamp */
  lastFeeUpdateTs: number | bigint;
  /** When the liquidation starts */
  liquidationStartTs: number | bigint;
  /**
   * The period (in seconds) that a vault depositor must wait after requesting a withdrawal to finalize withdrawal.
   * Currently, the maximum is 90 days.
   */
  redeemPeriod: number | bigint;
  /** The sum of all outstanding withdraw requests */
  totalWithdrawRequested: number | bigint;
  /** Max token capacity, once hit/passed vault will reject new deposits (updatable) */
  maxTokens: number | bigint;
  /**
   * The annual fee charged on deposits by the manager.
   * Traditional funds typically charge 2% per year on assets under management.
   */
  managementFee: number | bigint;
  /** Timestamp vault initialized */
  initTs: number | bigint;
  /** The net deposits for the vault */
  netDeposits: number | bigint;
  /** The net deposits for the manager */
  managerNetDeposits: number | bigint;
  /** Total deposits */
  totalDeposits: number | bigint;
  /** Total withdraws */
  totalWithdraws: number | bigint;
  /** Total deposits for the manager */
  managerTotalDeposits: number | bigint;
  /** Total withdraws for the manager */
  managerTotalWithdraws: number | bigint;
  /** Total management fee accrued by the manager */
  managerTotalFee: number | bigint;
  /** Total profit share accrued by the manager */
  managerTotalProfitShare: number | bigint;
  /** The minimum deposit amount */
  minDepositAmount: number | bigint;
  lastManagerWithdrawRequest: WithdrawRequestArgs;
  /** The base 10 exponent of the shares (given massive share inflation can occur at near zero vault equity) */
  sharesBase: number;
  /** Percentage the manager charges on all profits realized by depositors: PERCENTAGE_PRECISION */
  profitShare: number;
  /** Vault manager only collect incentive fees during periods when returns are higher than this amount: PERCENTAGE_PRECISION */
  hurdleRate: number;
  /** The spot market index the vault deposits into/withdraws from */
  spotMarketIndex: number;
  /** The bump for the vault pda */
  bump: number;
  /** Whether anybody can be a depositor */
  permissioned: boolean;
  /** The optional [`VaultProtocol`] account. */
  vaultProtocol: boolean;
  /** How fuel distribution should be treated [`FuelDistributionMode`]. Default is `UsersOnly` */
  fuelDistributionMode: number;
  /**
   * Whether the vault has a FeeUpdate account [`FeeUpdateStatus`]. Default is `FeeUpdateStatus::None`
   * After a `FeeUpdate` account is created and the manager has staged a fee update, the status is set to `PendingFeeUpdate`.
   * And instructsions that may finalize the fee update must include the `FeeUpdate` account with `remaining_accounts`.
   */
  feeUpdateStatus: number;
  /** The class of the vault [`VaultClass`]. Default is `VaultClass::Normal` */
  vaultClass: number;
  /** The timestamp cumulative_fuel_per_share was last updated */
  lastCumulativeFuelPerShareTs: number;
  /** The cumulative fuel per share (scaled up by 1e6 to avoid losing precision) */
  cumulativeFuelPerShare: number | bigint;
  /** The total fuel accumulated */
  cumulativeFuel: number | bigint;
  /**
   * The total value (in deposit asset) of borrows the manager has outstanding.
   * Purely for informational purposes for assets that have left the vault that the manager
   * is expected to return.
   */
  managerBorrowedValue: number | bigint;
  padding: Array<number | bigint>;
};

export function getVaultEncoder(): FixedSizeEncoder<VaultArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['name', fixEncoderSize(getBytesEncoder(), 32)],
      ['pubkey', getAddressEncoder()],
      ['manager', getAddressEncoder()],
      ['tokenAccount', getAddressEncoder()],
      ['userStats', getAddressEncoder()],
      ['user', getAddressEncoder()],
      ['delegate', getAddressEncoder()],
      ['liquidationDelegate', getAddressEncoder()],
      ['userShares', getU128Encoder()],
      ['totalShares', getU128Encoder()],
      ['lastFeeUpdateTs', getI64Encoder()],
      ['liquidationStartTs', getI64Encoder()],
      ['redeemPeriod', getI64Encoder()],
      ['totalWithdrawRequested', getU64Encoder()],
      ['maxTokens', getU64Encoder()],
      ['managementFee', getI64Encoder()],
      ['initTs', getI64Encoder()],
      ['netDeposits', getI64Encoder()],
      ['managerNetDeposits', getI64Encoder()],
      ['totalDeposits', getU64Encoder()],
      ['totalWithdraws', getU64Encoder()],
      ['managerTotalDeposits', getU64Encoder()],
      ['managerTotalWithdraws', getU64Encoder()],
      ['managerTotalFee', getI64Encoder()],
      ['managerTotalProfitShare', getU64Encoder()],
      ['minDepositAmount', getU64Encoder()],
      ['lastManagerWithdrawRequest', getWithdrawRequestEncoder()],
      ['sharesBase', getU32Encoder()],
      ['profitShare', getU32Encoder()],
      ['hurdleRate', getU32Encoder()],
      ['spotMarketIndex', getU16Encoder()],
      ['bump', getU8Encoder()],
      ['permissioned', getBooleanEncoder()],
      ['vaultProtocol', getBooleanEncoder()],
      ['fuelDistributionMode', getU8Encoder()],
      ['feeUpdateStatus', getU8Encoder()],
      ['vaultClass', getU8Encoder()],
      ['lastCumulativeFuelPerShareTs', getU32Encoder()],
      ['cumulativeFuelPerShare', getU128Encoder()],
      ['cumulativeFuel', getU128Encoder()],
      ['managerBorrowedValue', getU64Encoder()],
      ['padding', getArrayEncoder(getU64Encoder(), { size: 2 })],
    ]),
    (value) => ({ ...value, discriminator: VAULT_DISCRIMINATOR })
  );
}

export function getVaultDecoder(): FixedSizeDecoder<Vault> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['name', fixDecoderSize(getBytesDecoder(), 32)],
    ['pubkey', getAddressDecoder()],
    ['manager', getAddressDecoder()],
    ['tokenAccount', getAddressDecoder()],
    ['userStats', getAddressDecoder()],
    ['user', getAddressDecoder()],
    ['delegate', getAddressDecoder()],
    ['liquidationDelegate', getAddressDecoder()],
    ['userShares', getU128Decoder()],
    ['totalShares', getU128Decoder()],
    ['lastFeeUpdateTs', getI64Decoder()],
    ['liquidationStartTs', getI64Decoder()],
    ['redeemPeriod', getI64Decoder()],
    ['totalWithdrawRequested', getU64Decoder()],
    ['maxTokens', getU64Decoder()],
    ['managementFee', getI64Decoder()],
    ['initTs', getI64Decoder()],
    ['netDeposits', getI64Decoder()],
    ['managerNetDeposits', getI64Decoder()],
    ['totalDeposits', getU64Decoder()],
    ['totalWithdraws', getU64Decoder()],
    ['managerTotalDeposits', getU64Decoder()],
    ['managerTotalWithdraws', getU64Decoder()],
    ['managerTotalFee', getI64Decoder()],
    ['managerTotalProfitShare', getU64Decoder()],
    ['minDepositAmount', getU64Decoder()],
    ['lastManagerWithdrawRequest', getWithdrawRequestDecoder()],
    ['sharesBase', getU32Decoder()],
    ['profitShare', getU32Decoder()],
    ['hurdleRate', getU32Decoder()],
    ['spotMarketIndex', getU16Decoder()],
    ['bump', getU8Decoder()],
    ['permissioned', getBooleanDecoder()],
    ['vaultProtocol', getBooleanDecoder()],
    ['fuelDistributionMode', getU8Decoder()],
    ['feeUpdateStatus', getU8Decoder()],
    ['vaultClass', getU8Decoder()],
    ['lastCumulativeFuelPerShareTs', getU32Decoder()],
    ['cumulativeFuelPerShare', getU128Decoder()],
    ['cumulativeFuel', getU128Decoder()],
    ['managerBorrowedValue', getU64Decoder()],
    ['padding', getArrayDecoder(getU64Decoder(), { size: 2 })],
  ]);
}

export function getVaultCodec(): FixedSizeCodec<VaultArgs, Vault> {
  return combineCodec(getVaultEncoder(), getVaultDecoder());
}

export function decodeVault<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress>
): Account<Vault, TAddress>;
export function decodeVault<TAddress extends string = string>(
  encodedAccount: MaybeEncodedAccount<TAddress>
): MaybeAccount<Vault, TAddress>;
export function decodeVault<TAddress extends string = string>(
  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>
): Account<Vault, TAddress> | MaybeAccount<Vault, TAddress> {
  return decodeAccount(
    encodedAccount as MaybeEncodedAccount<TAddress>,
    getVaultDecoder()
  );
}

export async function fetchVault<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<Account<Vault, TAddress>> {
  const maybeAccount = await fetchMaybeVault(rpc, address, config);
  assertAccountExists(maybeAccount);
  return maybeAccount;
}

export async function fetchMaybeVault<TAddress extends string = string>(
  rpc: Parameters<typeof fetchEncodedAccount>[0],
  address: Address<TAddress>,
  config?: FetchAccountConfig
): Promise<MaybeAccount<Vault, TAddress>> {
  const maybeAccount = await fetchEncodedAccount(rpc, address, config);
  return decodeVault(maybeAccount);
}

export async function fetchAllVault(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<Account<Vault>[]> {
  const maybeAccounts = await fetchAllMaybeVault(rpc, addresses, config);
  assertAccountsExist(maybeAccounts);
  return maybeAccounts;
}

export async function fetchAllMaybeVault(
  rpc: Parameters<typeof fetchEncodedAccounts>[0],
  addresses: Array<Address>,
  config?: FetchAccountsConfig
): Promise<MaybeAccount<Vault>[]> {
  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);
  return maybeAccounts.map((maybeAccount) => decodeVault(maybeAccount));
}

export function getVaultSize(): number {
  return 536;
}
